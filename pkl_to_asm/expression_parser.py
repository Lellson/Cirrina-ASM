# Generated by ChatGPT
import re

def tokenize(expression):
    token_patterns = {
        'NUMBER': r'\d+',  # Integer numbers
        'IDENTIFIER': r'[a-zA-Z_][a-zA-Z0-9_]*',  # Identifiers (variable names)
        'OPERATOR': r'==|!=|<=|>=|&&|\|\||[-+*/%<>=!]',  # Operators
        'PARENTHESIS': r'[()]',  # Parentheses
        'WHITESPACE': r'\s+',  # Spaces
    }
    
    token_regex = '|'.join(f'(?P<{key}>{value})' for key, value in token_patterns.items())
    token_re = re.compile(token_regex)
    
    tokens = []
    for match in token_re.finditer(expression):
        kind = match.lastgroup
        value = match.group(kind)
        if kind == 'WHITESPACE':
            continue
        tokens.append((kind, value))
    return tokens

def parse_tokens(tokens):
    def parse_primary(tokens):
        if not tokens:
            raise ValueError("Unexpected end of input")
        token_type, token_value = tokens.pop(0)
        if token_type == 'NUMBER':
            return [int(token_value)]
        elif token_type == 'IDENTIFIER':
            if token_value == "true":
                return [True]
            if token_value == "false":
                return [False]
            return [token_value]
        elif token_type == 'PARENTHESIS' and token_value == '(':
            expr = parse_tokens(tokens)
            if not tokens or tokens.pop(0)[1] != ')':
                raise ValueError("Mismatched parentheses")
            return expr
        raise ValueError(f"Unexpected token: {token_value}")
    
    def parse_unary_expression(tokens):
        if tokens and tokens[0][1] in ('!', '-', '+'):
            op = tokens.pop(0)[1]
            return [op, parse_unary_expression(tokens)]
        return parse_primary(tokens)
    
    def parse_binary_expression(tokens, min_precedence=1):
        lhs = parse_unary_expression(tokens)
        while tokens and tokens[0][1] in ('+', '-', '*', '/', '%', '==', '!=', '<', '<=', '>', '>=', '&&', '||'):
            op = tokens[0][1]
            op_precedence = get_precedence(op)
            if op_precedence < min_precedence:
                break
            tokens.pop(0)  # Consume the operator
            rhs = parse_binary_expression(tokens, op_precedence + 1)
            lhs = [lhs, op, rhs]
        return lhs
    
    def get_precedence(op):
        precedence = {
            '!': 5,  # Highest precedence for unary
            '*': 4, '/': 4, '%': 4,  # Multiplication/Division/Modulo
            '+': 3, '-': 3,  # Addition/Subtraction
            '==': 2, '!=': 2, '<': 2, '<=': 2, '>': 2, '>=': 2,  # Comparison
            '&&': 1, '||': 1,  # Logical AND/OR
        }
        return precedence.get(op, -1)
    
    return parse_binary_expression(tokens)

def parse(expression):
    tokens = tokenize(expression)
    parsed_expression = parse_tokens(tokens)
    return parsed_expression

#print(parse("1"))  # Output: [1]
#print(parse("i + (x * 2)"))  # Output: [["i"], "+", [["x"], "*", [2]]]
#print(parse("!(a && b)"))  # Output: ["!", ["a", "&&", "b"]]
#print(parse("a && b || c"))  # Output: [["a", "&&", "b"], "||", "c"]